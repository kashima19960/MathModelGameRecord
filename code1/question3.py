import pandas as pd
import numpy as np
from pulp import LpMaximize, LpProblem, LpVariable, lpSum
import sys

sys.stdout = open("test3.csv", "w",encoding="utf-8")
# 1. 读取Excel文件中的数据
df_land = pd.read_excel("附件/附件1.xlsx")  # 附件1，地块信息
df_crops = pd.read_excel("附件/附件2.xlsx")  # 附件2，2023年农作物种植数据

# 2. 清理列名，防止因列名中有空格等字符引起错误
df_land.columns = df_land.columns.str.strip()  # 清除列名中的多余空格
df_crops.columns = df_crops.columns.str.strip()

# 3. 提取必要的数据
land_area = df_land["地块面积/亩"].values  # 各地块的面积
crop_names = df_crops["作物名称"].values  # 作物名称
# 以下使用假设数据，你需要根据实际数据进行调整
crop_prices = [3.25, 7.5, 8.25, 7.0, 6.75, 3.5, 3.0, 6.75, 6.0, 7.5, 40.0, 1.5, 3.25, 5.5, 3.5, 3.25, 7.5, 8.25, 7.0, 6.75, 3.5, 3.0, 6.75, 6.0, 7.5, 40.0, 1.5, 3.25, 5.5, 3.5, 3.25, 7.5, 8.25, 7.0, 6.75, 3.5, 3.0, 6.75, 6.0, 7.5, 40.0, 1.5, 3.25, 5.5, 3.5, 7.0, 8.0, 6.75, 6.5, 3.75, 6.25, 5.5, 5.75, 5.25, 5.5, 6.5, 5.0, 5.75, 7.0, 5.25, 7.25, 4.5, 4.5, 4.0, 8.0, 6.75, 6.5, 3.75, 6.25, 5.5, 5.75, 5.25, 5.5, 6.5, 5.0, 5.75, 7.0, 5.25, 7.25, 4.5, 4.5, 4.0, 2.5, 2.5, 3.25, 57.5, 19.0, 16.0, 100.0, 9.6, 8.1, 7.8, 4.5, 7.5, 6.6, 6.9, 6.8, 6.6, 7.8, 6.0, 6.9, 8.4, 6.3, 8.7, 5.4, 5.4, 4.8] # 作物的价格，假设为随机值
crop_costs = [400.0, 400.0, 350.0, 350.0, 350.0, 450.0, 500.0, 360.0, 400.0, 360.0, 350.0, 1000.0, 2000.0, 400.0, 350.0, 4000.0, 400.0, 350.0, 350.0, 350.0, 450.0, 500.0, 360.0, 400.0, 360.0, 350.0, 1000.0, 2000.0, 400.0, 350.0, 400.0, 400.0, 3500.0, 350.0, 350.0, 450.0, 500.0, 360.0, 400.0, 360.0, 350.0, 1000.0, 2000.0, 400.0, 350.0, 680.0, 2000.0, 1000.0, 2000.0, 2000.0, 2000.0, 2000.0, 2300.0, 1600.0, 2400.0, 2900.0, 1600.0, 1600.0, 2900.0, 1600.0, 1000.0, 4100.0, 2000.0, 9000.0, 2400.0, 1200.0, 2400.0, 2400.0, 2400.0, 2400.0, 2700.0, 2000.0, 3000.0, 3500.0, 2000.0, 2000.0, 350.0, 2000.0, 1200.0, 5000.0, 2500.0, 1100.0, 2000.0, 500.0, 500.0, 3000.0, 2000.0, 1000.0, 1000.0, 2640.0, 1320.0, 2640.0, 2640.0, 2640.0, 2640.0, 3000.0, 2200.0, 3300.0, 3850.0, 2200.0, 2200.0, 3850.0, 2200.0, 1300.0, 5500.0, 2750.0, 1200.0]  # 作物种植成本

crop_yield = [400.0, 500.0, 400.0, 350.0, 415.0, 800.0, 1000.0, 400.0, 630.0, 525.0, 110.0, 3000.0, 2200.0, 420.0, 525.0, 380.0, 475.0, 380.0, 330.0, 395.0, 760.0, 950.0, 380.0, 600.0, 500.0, 105.0, 2850.0, 2100.0, 400.0, 500.0, 360.0, 450.0, 360.0, 315.0, 375.0, 720.0, 900.0, 360.0, 570.0, 475.0, 100.0, 2700.0, 2000.0, 380.0, 475.0, 500.0, 3000.0, 2000.0, 3000.0, 2000.0, 2400.0, 6400.0, 2700.0, 2400.0, 3300.0, 3700.0, 4100.0, 3200.0, 12000.0, 4100.0, 1600.0, 10000.0, 5000.0, 5500.0, 3600.0, 2400.0, 3600.0, 2400.0, 3000.0, 8000.0, 3300.0, 3000.0, 4000.0, 4500.0, 5000.0, 4000.0, 15000.0, 5000.0, 2000.0, 12000.0, 6000.0, 6600.0, 5000.0, 4000.0, 3000.0, 5000.0, 4000.0, 10000.0, 1000.0, 3200.0, 2200.0, 3200.0, 2200.0, 2700.0, 7200.0, 3000.0, 2700.0, 3600.0, 4100.0, 4500.0, 3600.0, 13500.0, 4500.0, 1800.0, 11000.0, 5400.0, 6000.0]  # 作物的亩产量
crop_sales = [6400.0, 55000.0, 3500.0, 2880.0, 23800.0, 22000.0, 45600.0, 21850.0, 15200.0, 9240.0, 9875.0, 32680.0, 41800.0, 1720.0, 30000.0, 12500.0, 22800.0, 42750.0, 1400.0, 1000.0, 1500.0, 3510.0, 5400.0, 36010.0, 19440.0, 7200.0, 30000.0, 60000.0, 32000.0, 5000.0, 33600.0, 70000.0, 38400.0, 30500.0, 30000.0, 40000.0, 24000.0, 36000.0, 11000.0, 1000.0, 1440.0, 3000.0, 1800.0, 3000.0, 2400.0, 3000.0, 2700.0, 2400.0, 2400.0, 2400.0, 3000.0, 2400.0, 2160.0, 6000.0, 2160.0, 6000.0, 1440.0, 6000.0, 2160.0, 600.0, 2160.0, 600.0, 4800.0, 600.0, 1800.0, 600.0, 9000.0, 600.0, 1500.0, 1500.0, 600.0, 1200.0, 6020.0, 3300.0, 1620.0, 810.0, 8010.0, 1080.0, 1230.0, 2160.0, 4050.0, 1920.0, 1080.0, 1350.0, 1920.0, 1800.0, 9000.0]   # 作物的预期销售量

n_land = len(land_area)  # 地块数量
n_crops = len(crop_names)  # 作物数量
years = range(2024, 2031)  # 2024-2030年

# 4. 创建优化问题
prob = LpProblem("Optimal_Crop_Plan", LpMaximize)

# 5. 定义决策变量
# x[i, j, t] 表示在第 t 年地块 i 上种植作物 j 的面积
x = LpVariable.dicts(
    "x",
    ((i, j, t) for i in range(n_land) for j in range(n_crops) for t in years),
    lowBound=0,
    cat="Continuous",
)

# 定义辅助变量 P[i, j, t] 表示实际销售的作物数量，必须小于或等于预期销售量和实际产量
P = LpVariable.dicts(
    "P",
    ((i, j, t) for i in range(n_land) for j in range(n_crops) for t in years),
    lowBound=0,
    cat="Continuous",
)

# 定义二元变量 z[i, j, t]，表示第 t 年在地块 i 上是否种植作物 j
z = LpVariable.dicts(
    "z",
    ((i, j, t) for i in range(n_land) for j in range(n_crops) for t in years),
    0,
    1,
    cat="Binary",
)

# 6. 目标函数：最大化收益
objective = lpSum(
    P[i, j, t] * crop_prices[j] - x[i, j, t] * crop_costs[j]
    for i in range(n_land)
    for j in range(n_crops)
    for t in years
)

prob += objective  # 将目标函数加入问题

# 7. 添加约束条件

# (1) 地块面积限制
for i in range(n_land):
    for t in years:
        prob += (
            lpSum(x[i, j, t] for j in range(n_crops)) <= land_area[i]
        )  # 每块地的总种植面积不能超过该地块的面积

# (2) P[i, j, t] 受两方面限制：
# a. 不能超过预期销售量
# b. 不能超过实际产量（x[i, j, t] * crop_yield[j]）
for i in range(n_land):
    for j in range(n_crops):
        for t in years:
            prob += P[i, j, t] <= crop_sales[j]  # 不超过预期销售量
            prob += P[i, j, t] <= x[i, j, t] * crop_yield[j]  # 不超过实际产量

# (3) 不重茬约束：同一地块不能连续两年种植相同作物
# 通过二元变量 z[i, j, t] 实现不重茬
for i in range(n_land):
    for j in range(n_crops):
        for t in range(2025, 2031):  # 从2025年开始，检查前一年的种植情况
            prob += (
                z[i, j, t] + z[i, j, t - 1] <= 1
            )  # 如果 t 年种植作物 j，则 t-1 年不能种植同一作物

# (4) 确保 z[i, j, t] 与 x[i, j, t] 一致
for i in range(n_land):
    for j in range(n_crops):
        for t in years:
            # 如果种植作物 j 的面积大于 0，则 z[i, j, t] 为 1，否则为 0
            prob += x[i, j, t] <= z[i, j, t] * land_area[i]
            prob += x[i, j, t] >= z[i, j, t] * 0.01  # 小于 0.01 认为没种植

# (5) 豆类作物三年内必须种植一次
for i in range(n_land):
    for t in range(2024, 2031, 3):  # 每三年检查一次
        prob += (
            lpSum(
                z[i, j, t + k]
                for j in range(n_crops)
                if "豆类" in crop_names[j]
                for k in range(3)
            )
            >= 1
        )

# 8. 求解模型
prob.solve()

# 9. 输出结果
print(f"地块名称,作物,年份,面积/亩")
for i in range(n_land):
    for j in range(n_crops):
        for t in years:
            if x[i, j, t].varValue > 0:
                print(
                    f"{i+1},{crop_names[j]},{t},{x[i, j, t].varValue}"
                )


path="test3.csv"
df= pd.read_csv(path)

sequence_to_land_plot = {1: 'A1', 2: 'A2', 3: 'A3', 4: 'A4', 5: 'A5', 6: 'A6', 7: 'B1', 8: 'B2', 9: 'B3', 10: 'B4', 11: 'B5', 12: 'B6', 13: 'B7', 14: 'B8', 15: 'B9', 16: 'B10', 17: 'B11', 18: 'B12', 19: 'B13', 20: 'B14', 21: 'C1', 22: 'C2', 23: 'C3', 24: 'C4', 25: 'C5', 26: 'C6', 27: 'D1', 28: 'D2', 29: 'D3', 30: 'D4', 31: 'D5', 32: 'D6', 33: 'D7', 34: 'D8', 35: 'E1', 36: 'E2', 37: 'E3', 38: 'E4', 39: 'E5', 40: 'E6', 41: 'E7', 42: 'E8', 43: 'E9', 44: 'E10', 45: 'E11', 46: 'E12', 47: 'E13', 48: 'E14', 49: 'E15', 50: 'E16', 51: 'F1', 52: 'F2', 53: 'F3', 54: 'F4'}
df['地块名称'] = df['地块名称'].map(sequence_to_land_plot)
df.to_csv(path, index=False)